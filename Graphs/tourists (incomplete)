#include <bits/stdc++.h>

using namespace std;
typedef long long ll;

int n;
vector<int> adj[200001];
vector<pair<int,int> >pos;
int dep[200001];
bool visit[200001];

void calcdep(){
    queue<int>q;
    q.push(1);
    visit[1]=true;
    dep[1]=1;
    while(!q.empty()){
        int cur=q.front();
        //cout<<q.size()<<" ";
        q.pop();
        for(int i=0;i<adj[cur].size();i++){
            int next=adj[cur][i];
            if(!visit[next]){
                dep[next]=dep[cur]+1;
                visit[next]=true;
                q.push(next);
            }
        }
    }
}

struct segtree{
    vector<ll>tree;
    vector<ll>lazy;
    vector<ll>lo;
    vector<ll>hi;
    segtree(ll sz){
        tree.resize(4*sz+1);
        lazy.resize(4*sz+1);
        lo.resize(4*sz+1);
        hi.resize(4*sz+1);
        init(1,0,sz-1);
    }
    void init(ll node, ll a, ll b){
        lo[node]=a; hi[node]=b;
        if(a==b) return;
        int split=(a+b)/2;
        init(2*node,a,split);
        init(2*node+1,split+1,b);
    }
    void update(ll a, ll b, ll val){
        hupdate(1,a,b,val);
    }
    ll minquery(ll a, ll b){
        return hminquery(1,a,b);
    }
    void prop(ll node){
        lazy[2*node]+=lazy[node];
        lazy[2*node+1]+=lazy[node];
        lazy[node]=0;
    }
    void change(ll node){
        tree[node]=min(tree[2*node+1] + lazy[2*node+1], tree[2*node] + lazy[2*node]);
    }
    void hupdate(ll node, ll a, ll b, ll val){
        if(b<lo[node] || hi[node]<a) return;
        if(a<=lo[node] && hi[node]<=b){
            lazy[node]+=val;
            return;
        }
        prop(node);
        hupdate(2*node,a,b,val);
        hupdate(2*node+1,a,b,val);
        change(node);
    }
    ll hminquery(ll node, ll a, ll b){
        if(b<lo[node] || hi[node]<a) return LONG_MAX;
        if(a<=lo[node] && hi[node]<=b){
            return tree[node]+lazy[node];
        }
        prop(node);
        ll left=hminquery(2*node, a, b);
        ll right=hminquery(2*node+1,a,b);
        change(node);
        return min(left, right);
    }
};

vector<int>euler;

void lca(){

}

int main()
{
    cin>>n;
    for(int i=0;i<n-1;i++){
        int a, b; cin>>a>>b;
        adj[a].push_back(b);
        adj[b].push_back(a);
    }
    for(int i=1;i<=n;i++){
        for(int j=i+i;j<=n;j+=i){
            pos.push_back(make_pair(i,j));
        }
    }
    calcdep();
    
    return 0;
}
